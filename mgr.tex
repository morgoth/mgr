\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{float}

\input{pygments}

\providecommand{\imref}[1]{Rys. \ref{#1}} % referencja do obrazka

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{leo}

\newfloat{listing}{thpb}{lol}
\floatname{listing}{Listing}

\begin{document}

\author{Wojciech Wnętrzak}
\title{Opracowanie elastycznego systemu organizacji testów internetowych do zdalnej
edukacji w oparciu o technologię Ruby on Rails}
\date{\today}

\begin{titlepage}
\maketitle
\end{titlepage}

\section{Technologie}
\subsection{Ruby}
\emph{Ruby} został stworzony w 1995 roku przez Yukihiro Matsumoto, znanego również
pod pseudonimem Matz. Łączy on w sobie cechy kilku języków, między innymi: \emph{Lispa},
\emph{Perla}, \emph{Pythona} czy \emph{Smalltalka}, z każdego wybierając to co najlepsze,
w efekcie dając elastyczne narzędzie, o wielkich możliwościach.\\
Jest to język skryptowy -- aby spróbować jego możliwości wystarczy nam konsolowy
interpreter, z poziomu którego wydajemy polecenia, otrzymując od razu wynik działania.


\emph{Ruby} należy do grupy języków bardzo wysokiego poziomu programowania
(\emph{VHLL})\footnote{VHLL -- Very High-Level Programming Language (ang.)}.
W bibliotece standardowej otrzymujemy szereg metod, dzięki którym bez zbytniego wysiłku,
czasem nawet w jednej linijce, możemy napisać skrypt wykonujący złożone działania.\\
Jedną z głównych cech tego języka, która rzuca się w oczy od razu, jest tzw.
,,samokomentujący się kod''. Składnia jest bardzo zbliżona do języka naturalnego
(angielskiego), dzięki czemu nawet osoba nie mająca nic wspólnego z programowaniem,
powinna przewidzieć co dany kawałek kodu wykonuje. Przykładem niech będzie:
\begin{listing}
  \input{listing/selfcommenting}
  \caption{Samokomentujący się kod}
  \label{listing:selfcommenting}
\end{listing}


Ciekawą własnością jest tzw. kacze typowanie\footnote{Duck typing (ang.)}, które polega na
rozpoznaniu typu poprzez zachowanie obiektu a nie jego deklaracji. Przykładowo: jeśli mamy
funkcję przyjmującą argument, to nie musimy określać jakiego on będzie typu, dzięki czemu
możemy wywołać na nim metodę (jeśli takową posiada), odpowiednią dla klasy obiektu. Nazwa
wzięła się z powiedzienia ,,Jeśli chodzi jak kaczka i kwacze jak kaczka, to musi być
kaczką''\footnote{''If it walks like a duck and quacks like a duck, I would call it a duck''
-- James Whitcomb Riley (ang.)}


Kolejną cechą, która jest jedną z najsilniejszych, jest metaprogramowanie. Nie tyle sama
możliwość, co raczej przystępność i prostota jego użycia. Framework \emph{Ruby on Rails}
korzysta bardzo często z jego dobrodziejstw, dając nam tzw. ,,magię railsów'', czyli
między innymi dynamiczne findery, niemalże bezdeklaratywne asocjacje czy szereg innych
metod o których więcej w kolejnym podrozdziale.\\
Ogólnie rzecz biorąc język \emph{Ruby} wraz ze swoimi otwartymi klasami, stwarza
programiście przestrzeń, w której może się skupić wyłącznie na postawionym problemie, nie
martwiąc się o przeszkody techniczne, takie jak dostęp do modyfikacji metod z zewnętrznych
bibliotek czy rozszerzanie klas o nowe funkcjonalności. Sposób pisania jest intuicyjny,
działa tu zasada najmniejszego zaskoczenia. Często, powstające nowe biblioteki (gemy), trzymają
się kilku ustalonych konwencji, dzięki czemu zgłębiając nowe funkcjonalności, odnajdujemy
duże podobieństwa do już dobrze znanych nam metod, choćby z biblioteki standardowej.

\clearpage
\subsection{Ruby on Rails}
Twórcą frameworka \emph{Ruby on Rails} jest David Heinemeier Hansson. Powstał on w 2003
roku, obecnie rozwijany cały czas przez społeczność użytkowników i czuwającą nad
spójnością kodu tzw. \emph{Core Team}. Jest to produkt wolnego
oprogramowania\footnote{Open source (ang.)}, wypuszczony na licencji
\emph{MIT}.\footnote{Licencja powstała w Massachusetts Institute of Technology}\\
Framework jest kompletnym narzędziem do tworzenia aplikacji internetowych z wykorzystaniem
bazy danych. Opiera się na wzorcu projektowym model-widok-kontroler\footnote{MVC -- Model View
Controller (ang.)} i w całości jest napisany w języku \emph{Ruby}.


Główną zasadą jaką kierują się twórcy, to tzw. konwencja nad
konfiguracją\footnote{Convention over Configuration (ang.)}, dzięki której przy minimalnej
ilości kodu, dostajemy ogromną funkcjonalność, co znacznie przyspiesza tworzenie
aplikacji. Świetnym przykładem jest \emph{screencast}, na którym Ryan
Bates\footnote{Ryan Bates -- jeden z aktywistów Ruby on Rails, znany głównie jako autor
darmowych, cotygodniowych screencastów \cite{ryan-bates}} tworzy w 15 minut szkielet
systemu blogowego, uwzględniając takie dodatki jak dostępność poprzez kanał
RSS\footnote{RSS -- Really Simple Syndication (ang.)} czy reprezentacja zasobów w postaci
\emph{XML}.\cite{blog-in-15-min}\\
Kolejną zaletą takiego podejścia, jest przejrzystość kodu. Dopóki postępujemy zgodnie ze
wskazówkami, nasz kod nie powinien być trudny do zrozumienia przez innego programistę
również zajmującego się tą technologią.\\
Drugą ideą składającą się na całość tzw. \emph{Rails way} jest zapobieganie powtarzaniu
samego siebie\footnote{DRY -- Don't Repeat Yourself (ang.)}. Jeśli w jakimś miejscu używamy
tego samego fragmentu kodu (czasem wręcz przeklejonego), to znaczy że możemy to zrobić
prościej. Pomoc przychodzi z samego języka \emph{Ruby}, w którym za pomocą mechanizmu
tzw. \emph{Mixinów}, możemy dodawać do interesujących nas klas czy modułów gotowe zestawy
metod, upraszczając w ten sposób strukturę kodu.


Po wygenerowaniu szkieletu projektu, dostajemy strukturę katalogów, które między innymi
oddzwierciedlają wykorzystanie wzorca \emph{MVC}. Pliki odpowiedzialne za interakcję z
bazą danych oraz główną logikę aplikacji znajdują się w katalogu \emph{models}. Część
generująca widoki, czyli dokumenty \emph{HTML} również mają swoje określone miejsce w
katalogu \emph{views}, natomiast część obsługująca akcje użytkownika przesyłane do serwera
oraz łącząca ze sobą poprzednio wymienione komponenty, jak nie trudno się domyślić, leży w
katalogu \emph{controllers}. Wszystko to zapewnia nam odpowiednią separację kodu, dzięki
czemu modyfikacje poszczególnych elementów, nie powinny wpływać na siebie.


\emph{Ruby on Rails} składa się z kilku odrębnych \emph{gemów}\footnote{Gemy -- system
paczek, bibliotek dostarczający nową funkcjonalność}, które mogą być również używane
osobno, poza frameworkiem (nie posiadają zależności między sobą). Są to:
\begin{itemize}
  \item ActionMailer
  \item ActionPack
  \item ActiveRecord
  \item ActiveResource
  \item ActiveSupport
\end{itemize}


\emph{ActionMailer} odpowiada za obsługę usług pocztowych wychodzących i przychodzących z
naszej aplikacji. Jako generator widoków może być używany \emph{ERb}\footnote{ERb --
Embedded Ruby (ang.) -- system szablonów umożliwiający zagnieżdżanie kodu Rubiego w
dokumencie tekstowym}. Konfiguracja jest możliwa dla każdego środowiska -- odpowiednio w
środowisku produkcyjnym mamy możliowość wpisania danych rzeczywistych serwera pocztowego,
natomiast w deweloperskim oraz testowym, możemy zastąpić ją wersją próbną, która nie
będzie próbowała się łączyć z serwerem pozctowym, natomiast cały mechanizm i logika
zostanie zachowana.


\emph{ActionPack} jest odpowiedzialny za obłsugę kontrolerów oraz widoków. Przychodzące
zapytanie z serwera jest wiązane z odpowiednią akcją kontrolera, przy pomocy tzw.
\emph{Routingu}, który mapuje ścieżkę adresu na parametry przekazywane do aplikacji.
Obecnie domyślny i preferowany sposób konstruowania ścieżek \emph{URL} jest zgodny z
\emph{REST}.\footnote{REST -- Representational State Transfer (ang.) -- reprezentacja zasobu
poprzez ,,czasowniki'' protokołu HTTP: GET, POST, PUT, DELETE (więcej na stronie~\pageref{sec:rest})}\\
Wywołana akcja musi zwrócić odpowiedź, bądź to w postaci wyrenderowanego widoku,
przekierowania czy też kodu błędu zgodnego z protokołem \emph{HTTP}. Ciekawym mechanizmem,
którym dysponuje moduł \emph{ActionController} są filtry. Pozwalają one na wyzwolenie
logiki przed lub po odwołaniu się do docelowej akcji. Często wykorzystywane są przy
autentykacji, gdzie chcemy zabezpieczyć treść strony przed niepowołanymi osobami. W tym
miejscu mamy też dostęp do ,,ciasteczek''\footnote{Cookies (ang.) -- niewielkie informacje
tekstowe przechowywane po stronie klienta} i sesji (rozwiązanie problemu bezstanowości
protokołu \emph{HTTP}). W \emph{Ruby on Rails} sesja jest niczym innym jak tablicą
asocjacyjną, do której możemy się odwoływać za pomocą kluczy. Sposób
przechowywania sesji pomiędzy kolejnymi żądaniami jest konfigurowalny i może być
składowany zarówno w bazie danych jak i w ciasteczku.\\
Najczęściej po wykonaniu akcji jest renderowany widok, zgodnie z konwencją jes to plik o
tej samej nazwie co akcja, znajdujący się w katalogu \emph{views} i podkatalogu
odpowiadającemu nazwie kontrolera (oczywiście jest możliwe przekazanie nazwy explicite).
Rozszerzenie pliku składa się z nazwy żądanego formatu (html, js, xml, etc.) oraz systemu
szablonów, który ma zostać użyty (erb, haml, builder, etc.) np. \emph{index.html.haml}.


\emph{ActiveRecord} działa jako domyślne mapowanie
obiektowo-relacyjne\footnote{ORM -- Object-Relational Mapping (ang.)},
czyli odzworowanie logiki powiązanych ze sobą modeli na bazę danych.
Nazwa została wzięta z książki Martina Fowlera\cite{martin-fowler}, która
właśnie opisuje powyższe zagadnienie. Moduł ten nie jest ściśle związany z żadną
wersją bazy danych i może być z powodzeniem używany z \emph{SQLite},
\emph{MySQL}, \emph{PostgreSQL} czy \emph{Oracle}. Pozwala między innymi na
konstruowanie zapytań za pomocą kodu \emph{Rubiego}, który później jest
przekształcany na odpowiadającą mu składnię \emph{SQLa}.
Przykład:
\begin{listing}
  \input{listing/activerecord_finders}
  \caption{Konstruowanie zapytań oraz wygenerowany kod SQL}
  \label{listing:activerecord_finders}
\end{listing}


Jak widzimy, w prosty sposób możemy konstruować zapytania, nie dotykając w ogóle
czystego \emph{SQLa}. Drugi i trzeci przykład wygenerowały to samo zapytanie.
Składnia tego ostatniego jest przyjemniejsza dla oka, a umożliwiają nam je tzw.
dynamiczne findery, które za pomocą metaprogramowania są tworzone w ,,locie''.
Jest to cecha języka \emph{Ruby}. Możemy przechwycić wywołanie nieistniejącej
metody na obiekcie, poprzez przedefiniowanie funkcji \emph{method\_missing},
która jako argumenty przyjmuje kolejno: symbol wywołanej metody, oraz wszystkie
pozostałe argumenty przekazane do niej. W powyższym przykładzie, symbol
\emph{:find\_by\_login} jest parsowany do słów \emph{find\_by} oraz \emph{login}, który
następnie próbuje zostać odnaleziony jako kolumna w tabeli odpowiadającej klasie
\emph{User}. Jeśli to się powiedzie, konstruowane jest zapytanie \emph{SQL}
wykorzystujące argument \emph{johndoe} jako parametr wywołania.


\clearpage
\section{Odległość Levenshteina}
Jednym z rodzajów tworzonego pytania jest pole tekstowe. Po wyborze tego właśnie typu, w
treści odpowiedzi wpisujemy wzorzec, który będzie porównany z odpowiedzią wpisaną przez
studenta.\\
Porównanie odbywa się na zasadzie przyrównywania kolejnych liter wzorca do otrzymanego
rozwiązania. Pojawia się jednak problem z tzw. ,,literówkami''. Co w przypadku gdy student
napisze dane słowo z dużej litery lub pomyli kolejność liter (często zdarzający się błąd)?
W celu rozwiązania powyższej przeszkody, przyjąłem dwa uproszczenia, mianowicie przy
porównaniu:
\begin{itemize}
  \item nie będzie brana pod uwagę wielkość liter
  \item na każde 6 liter wzorca jest możliwy jeden błąd
\end{itemize}
Do realizacji drugiego podpunktu została użyta odległość Levenshteina, która docelowo
oblicza wartość liczbową pomiędzy dwoma ciągami znaków, dzięki czemu jesteśmy w stanie
ocenić jak bardzo różnią się od siebie porównywane napisy.\\
Definicję można przedstawić w następujący sposób: \cite{levenshtein}\\
Odległością pomiędzy dwoma napisami jest najmniejsza liczba działań prostych,
przeprowadzających jeden napis w drugi, gdzie działaniem prostym nazwiemy:
\begin{itemize}
  \item wstawienie nowego znaku do napisu
  \item usunięcie znaku z napisu
  \item zamianę znaku w napisie na inny znak
\end{itemize}
Mając obliczoną odległość pomiędzy wzrocem a odpowiedzią, mierzymy długość wzorca i
dzielimy przez 6, jeśli wynik jest większy bądź równy od odległości, uznajemy odpowiedź
za poprawną. Liczba 6 została zaczerpnięta z polskiej wersji portalu NerdQuiz, gdzie
zastosowany jest podobny mechanizm oceny.

\clearpage
\bibliographystyle{plain}
\bibliography{bibliografia}
\end{document}
