\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{float}

\input{pygments}

\providecommand{\imref}[1]{Rys. \ref{#1}} % referencja do obrazka

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{leo}

\newfloat{listing}{htp}{lol}
\floatname{listing}{Listing}

\begin{document}

\author{Wojciech Wnętrzak}
\title{Opracowanie elastycznego systemu organizacji testów internetowych do zdalnej
edukacji w oparciu o technologię Ruby on Rails}
\date{\today}

\begin{titlepage}
\maketitle
\end{titlepage}

\section{Technologie}
\subsection{Ruby}
\emph{Ruby} został stworzony w 1995 roku przez Yukihiro Matsumoto, znanego również
pod pseudonimem Matz. Łączy on w sobie cechy kilku języków, między innymi: \emph{Lispa},
\emph{Perla}, \emph{Pythona} czy \emph{Smalltalka}, z każdego wybierając to co najlepsze,
w efekcie dając elastyczne narzędzie, o wielkich możliwościach.\\
Jest to język skryptowy -- aby spróbować jego możliwości wystarczy nam konsolowy
interpreter, z poziomu którego wydajemy polecenia, otrzymując od razu wynik działania.


\emph{Ruby} należy do grupy języków bardzo wysokiego poziomu programowania
(\emph{VHLL})\footnote{VHLL -- Very High-Level Programming Language (ang.)}.
W bibliotece standardowej otrzymujemy szereg metod, dzięki którym bez zbytniego wysiłku,
czasem nawet w jednej linijce, możemy napisać skrypt wykonujący złożone działania.\\
Jedną z głównych cech tego języka, która rzuca się w oczy od razu, jest tzw.
,,samokomentujący się kod''. Składnia jest bardzo zbliżona do języka naturalnego
(angielskiego), dzięki czemu nawet osoba nie mająca nic wspólnego z programowaniem,
powinna przewidzieć co dany kawałek kodu wykonuje. Przykładem niech będzie
listing nr \ref{listing:selfcommenting}.
\begin{listing}
  \input{listing/selfcommenting}
  \caption{Samokomentujący się kod}
  \label{listing:selfcommenting}
\end{listing}


Ciekawą własnością jest tzw. kacze typowanie\footnote{Duck typing (ang.)}, które polega na
rozpoznaniu typu poprzez zachowanie obiektu a nie jego deklaracji. Przykładowo: jeśli mamy
funkcję przyjmującą argument, to nie musimy określać jakiego on będzie typu, dzięki czemu
możemy wywołać na nim metodę (jeśli takową posiada), odpowiednią dla klasy obiektu. Nazwa
wzięła się z powiedzienia ,,Jeśli chodzi jak kaczka i kwacze jak kaczka, to musi być
kaczką''\footnote{''If it walks like a duck and quacks like a duck, I would call it a duck''
-- James Whitcomb Riley (ang.)}


Kolejną cechą, która jest jedną z najsilniejszych, jest metaprogramowanie. Nie tyle sama
możliwość, co raczej przystępność i prostota jego użycia. Framework \emph{Ruby on Rails}
korzysta bardzo często z jego dobrodziejstw, dając nam tzw. ,,magię railsów'', czyli
między innymi dynamiczne findery, niemalże bezdeklaratywne asocjacje czy szereg innych
metod o których więcej w kolejnym podrozdziale.\\
Ogólnie rzecz biorąc język \emph{Ruby} wraz ze swoimi otwartymi klasami, stwarza
programiście przestrzeń, w której może się skupić wyłącznie na postawionym problemie, nie
martwiąc się o przeszkody techniczne, takie jak dostęp do modyfikacji metod z zewnętrznych
bibliotek czy rozszerzanie klas o nowe funkcjonalności. Sposób pisania jest intuicyjny,
działa tu zasada najmniejszego zaskoczenia. Często, powstające nowe biblioteki (gemy), trzymają
się kilku ustalonych konwencji, dzięki czemu zgłębiając nowe funkcjonalności, odnajdujemy
duże podobieństwa do już dobrze znanych nam metod, choćby z biblioteki standardowej.


\subsection{Ruby on Rails}
Twórcą frameworka \emph{Ruby on Rails} jest David Heinemeier Hansson. Powstał on w 2003
roku, obecnie rozwijany cały czas przez społeczność użytkowników i czuwającą nad
spójnością kodu tzw. \emph{Core Team}. Jest to produkt wolnego
oprogramowania\footnote{Open source (ang.)}, wypuszczony na licencji
\emph{MIT}.\footnote{Licencja powstała w Massachusetts Institute of Technology}\\
Framework jest kompletnym narzędziem do tworzenia aplikacji internetowych z wykorzystaniem
bazy danych. Opiera się na wzorcu projektowym model-widok-kontroler\footnote{MVC -- Model View
Controller (ang.)} i w całości jest napisany w języku \emph{Ruby}.


Główną zasadą jaką kierują się twórcy, to tzw. konwencja nad
konfiguracją\footnote{Convention over Configuration (ang.)}, dzięki której przy minimalnej
ilości kodu, dostajemy ogromną funkcjonalność, co znacznie przyspiesza tworzenie
aplikacji. Świetnym przykładem jest \emph{screencast}, na którym Ryan
Bates\footnote{Ryan Bates -- jeden z aktywistów Ruby on Rails, znany głównie jako autor
darmowych, cotygodniowych screencastów \cite{ryan-bates}} tworzy w 15 minut szkielet
systemu blogowego, uwzględniając takie dodatki jak dostępność poprzez kanał
RSS\footnote{RSS -- Really Simple Syndication (ang.)} czy reprezentacja zasobów w postaci
\emph{XML}.\cite{blog-in-15-min}\\
Kolejną zaletą takiego podejścia, jest przejrzystość kodu. Dopóki postępujemy zgodnie ze
wskazówkami, nasz kod nie powinien być trudny do zrozumienia przez innego programistę
również zajmującego się tą technologią.\\
Drugą ideą składającą się na całość tzw. \emph{Rails way} jest zapobieganie powtarzaniu
samego siebie\footnote{DRY -- Don't Repeat Yourself (ang.)}. Jeśli w jakimś miejscu używamy
tego samego fragmentu kodu (czasem wręcz przeklejonego), to znaczy że możemy to zrobić
prościej. Pomoc przychodzi z samego języka \emph{Ruby}, w którym za pomocą mechanizmu
tzw. \emph{Mixinów}, możemy dodawać do interesujących nas klas czy modułów gotowe zestawy
metod, upraszczając w ten sposób strukturę kodu.


Po wygenerowaniu szkieletu projektu, dostajemy strukturę katalogów, które między innymi
oddzwierciedlają wykorzystanie wzorca \emph{MVC}. Pliki odpowiedzialne za interakcję z
bazą danych oraz główną logikę aplikacji znajdują się w katalogu \emph{models}. Część
generująca widoki, czyli dokumenty \emph{HTML} również mają swoje określone miejsce w
katalogu \emph{views}, natomiast część obsługująca akcje użytkownika przesyłane do serwera
oraz łącząca ze sobą poprzednio wymienione komponenty, jak nie trudno się domyślić, leży w
katalogu \emph{controllers}. Wszystko to zapewnia nam odpowiednią separację kodu, dzięki
czemu modyfikacje poszczególnych elementów, nie powinny wpływać na siebie.


\subsubsection{Gemy}
\emph{Ruby on Rails} składa się z kilku odrębnych \emph{gemów}\footnote{Gemy -- system
paczek, bibliotek dostarczający nową funkcjonalność}, które mogą być również używane
osobno, poza frameworkiem (nie posiadają zależności między sobą). Są to:
\begin{itemize}
  \item ActionMailer
  \item ActionPack
  \item ActiveRecord
  \item ActiveResource
  \item ActiveSupport
\end{itemize}


\emph{ActionMailer} odpowiada za obsługę usług pocztowych wychodzących i przychodzących z
naszej aplikacji. Jako generator widoków może być używany \emph{ERb}\footnote{ERb --
Embedded Ruby (ang.) -- system szablonów umożliwiający zagnieżdżanie kodu Rubiego w
dokumencie tekstowym}. Konfiguracja jest możliwa dla każdego środowiska -- odpowiednio w
środowisku produkcyjnym mamy możliowość wpisania danych rzeczywistych serwera pocztowego,
natomiast w deweloperskim oraz testowym, możemy zastąpić ją wersją próbną, która nie
będzie próbowała się łączyć z serwerem pozctowym, natomiast cały mechanizm i logika
zostanie zachowana.


\emph{ActionPack} jest odpowiedzialny za obłsugę kontrolerów oraz widoków. Przychodzące
zapytanie z serwera jest wiązane z odpowiednią akcją kontrolera, przy pomocy tzw.
\emph{Routingu}, który mapuje ścieżkę adresu na parametry przekazywane do aplikacji.
Obecnie domyślny i preferowany sposób konstruowania ścieżek \emph{URL} jest zgodny z
\emph{REST}.\footnote{REST -- Representational State Transfer (ang.) -- reprezentacja zasobu
poprzez ,,czasowniki'' protokołu HTTP: GET, POST, PUT, DELETE (więcej na stronie~\pageref{sec:rest})}\\
Wywołana akcja musi zwrócić odpowiedź, bądź to w postaci wyrenderowanego widoku,
przekierowania czy też kodu błędu zgodnego z protokołem \emph{HTTP}. Ciekawym mechanizmem,
którym dysponuje moduł \emph{ActionController} są filtry. Pozwalają one na wyzwolenie
logiki przed lub po odwołaniu się do docelowej akcji. Często wykorzystywane są przy
autentykacji, gdzie chcemy zabezpieczyć treść strony przed niepowołanymi osobami. W tym
miejscu mamy też dostęp do ,,ciasteczek''\footnote{Cookies (ang.) -- niewielkie informacje
tekstowe przechowywane po stronie klienta} i sesji (rozwiązanie problemu bezstanowości
protokołu \emph{HTTP}). W \emph{Ruby on Rails} sesja jest niczym innym jak tablicą
asocjacyjną, do której możemy się odwoływać za pomocą kluczy. Sposób
przechowywania sesji pomiędzy kolejnymi żądaniami jest konfigurowalny i może być
składowany zarówno w bazie danych jak i w ciasteczku.\\
Najczęściej po wykonaniu akcji jest renderowany widok, zgodnie z konwencją jes to plik o
tej samej nazwie co akcja, znajdujący się w katalogu \emph{views} i podkatalogu
odpowiadającemu nazwie kontrolera (oczywiście jest możliwe przekazanie nazwy explicite).
Rozszerzenie pliku składa się z nazwy żądanego formatu (html, js, xml, etc.) oraz systemu
szablonów, który ma zostać użyty (erb, haml, builder, etc.) np. \emph{index.html.haml}.


\emph{ActiveRecord} działa jako domyślne mapowanie
obiektowo-relacyjne\footnote{ORM -- Object-Relational Mapping (ang.)},
czyli odzworowanie logiki powiązanych ze sobą modeli na bazę danych.
Nazwa została wzięta z książki Martina Fowlera\cite{martin-fowler}, która
właśnie opisuje powyższe zagadnienie. Moduł ten nie jest ściśle związany z żadną
wersją bazy danych i może być z powodzeniem używany z \emph{SQLite},
\emph{MySQL}, \emph{PostgreSQL} czy \emph{Oracle}. Pozwala między innymi na
konstruowanie zapytań za pomocą kodu \emph{Rubiego}, który później jest
przekształcany na odpowiadającą mu składnię \emph{SQLa}.
Przykład przedstawiony na listingu nr \ref{listing:activerecord_finders}.

\begin{listing}
  \input{listing/activerecord_finders}
  \caption{Konstruowanie zapytań oraz wygenerowany kod SQL}
  \label{listing:activerecord_finders}
\end{listing}


Jak widzimy, w prosty sposób możemy konstruować zapytania, nie dotykając w ogóle
czystego \emph{SQLa}. Drugi i trzeci przykład wygenerowały to samo zapytanie.
Składnia tego ostatniego jest przyjemniejsza dla oka, a umożliwiają nam je tzw.
dynamiczne findery, które za pomocą metaprogramowania są tworzone w ,,locie''.
Jest to cecha języka \emph{Ruby}. Możemy przechwycić wywołanie nieistniejącej
metody na obiekcie, poprzez przedefiniowanie funkcji \emph{method\_missing},
która jako argumenty przyjmuje kolejno: symbol wywołanej metody, oraz wszystkie
pozostałe argumenty przekazane do niej. W powyższym przykładzie, symbol
\emph{:find\_by\_login} jest parsowany do słów \emph{find\_by} oraz \emph{login}, który
następnie próbuje zostać odnaleziony jako kolumna w tabeli odpowiadającej klasie
\emph{User}. Jeśli to się powiedzie, konstruowane jest zapytanie \emph{SQL}
wykorzystujące argument \emph{johndoe} jako parametr wywołania.\\
Kolejnym elementem zbudowanym na metaprogramowaniu są asocjacje. Powiązanie
dwóch obiektów sprowadza się do jednej linijki kodu w ciele klasy, jak na
listingu nr \ref{listing:activerecord_association}.

\begin{listing}
  \input{listing/activerecord_association}
  \caption{Powiązanie dwóch obiektów ActiveRecord}
  \label{listing:activerecord_association}
\end{listing}


Jeśli trzymamy się konwencji, to powyższy zapis jest wystarczający, musimy tylko
pamiętać o umieszczeniu kolumny \texttt{student\_id} w tabeli \texttt{exams}. Jak
widzimy konstrukcja odpowiada naturalnej relacji w języku angielskim, dlatego
też nie powinno się używać lokalizowanych nazw tabel, co zapewnia spójność i
nie powoduje ,,potworków językowych'', takich jak \texttt{student has many
egzamins}. Po deklaracji asocjacji dostajemy automatycznie między innymi takie
metody jak przedstawione na listingu nr \ref{listing:activerecord_association_finders}.

\begin{listing}
  \input{listing/activerecord_association_finders}
  \caption{Dostępne metody po deklaracji asocjacji}
  \label{listing:activerecord_association_finders}
\end{listing}


Walidatory zapewniają nam poprawność wprowadzanych danych, dzięki którym również
możemy poinformować użytkownika o rodzaju błędu. Mamy do dyspozycji szereg
standardowych metod, najczęściej używanych, ale również możemy tworzyć swoje
własne. Przykładowy sposób użycia przedstawia listing nr \ref{listing:activerecord_validations}.

\begin{listing}
  \input{listing/activerecord_validations}
  \caption{Walidacja danych}
  \label{listing:activerecord_validations}
\end{listing}


W podanym przykładzie pierwsza walidacja zapewnia nam obecność nazwy egzaminu,
druga sprawdza czy czas trwania (\texttt{duration}) jest liczbą całkowitą większą od
zera. Ostatni walidator jest metodą zdefiniowaną przez nas, który ma być
wywołany jedynie gdy pole ,,ilość pytań'' (\texttt{question\_number}) jest obecne.
Zapewnia, że liczba ta nie może być większa niż ilość wszystkich dostępnych
pytań dla danego egzaminu. Symbol dodawanego błędu możemy następnie zlokalizować
w plikach z tłumaczeniami.


Kolejną przydatną rzeczą sa wywołania zwrotne -- pozwalają na manipulację
atrybutami, przed lub po walidacji, utworzeniu, uaktualnieniu lub usunięciu
obiektu z bazy dancyh. Dzięki temu możemy w dokładnie określonym momencie
wyzwolić odpowiednią logikę. Wywołania działają również przy deklarowanej
asocjacji, więc dodatkowo dostajemy możliwość wywołania metod przy dodawaniu i
usuwaniu powiązanych obiektów. Przykładowe \texttt{callbacki} na listingu nr~
\ref{listing:activerecord_callbacks}.

\begin{listing}
  \input{listing/activerecord_callbacks}
  \caption{Wywołania zwrotne}
  \label{listing:activerecord_callbacks}
\end{listing}


Operowanie atrybutami w podany sposób jest bardzo wygodne, szczególnie że mamy
zapewnioną atomowość modelu. Jeśli powiązane modele również są modyfikowane, to
w chwili np. błędu walidacji, lub innego niepowodzenia, wszystkie zmiany są
cofane do stanu pierwotnego. Innymi słowy, zmiany są wprowadzane do obiektów
tylko jeśli wszystko jest przeprowadzone pomyślnie. Z transakcji możemy również
korzystac jawnie, przekazując do metody \texttt{transaction} blok, w którym
wykonujemy interesujące nas akcje.


Zmian schematu bazy danych dokonujemy poprzez migracje. Są to pliki z kodem \emph{Rubiego
}, w których definiujemy wprowadzane tabele oraz poszczególne kolumny. Świetnie sprawdzają
się przy pracy w zespole, gdyż każdy plik jest oznaczony datą, a sama baza danych
przechowuje informację o aktualnej wersji, dlatego nie ma tu konflitków i nie musimy
przejmować się kolejnością wprowadzanych zmian. Mamy do dyspozycji kilka generatorów,
które znacznie ułatwiają i przyspieszają pracę. Dodatkowo bazują one na konwencji -- nazwa
modelu (klasy) w liczbie pojedynczej, natomiast nazwa kolumny w liczbie mnogiej, co
minimalizuje możliwość popełnienia błędu z naszej strony. Przykładowe polecenie, oraz
wygenerowany plik na listingu nr~\ref{listing:activerecord_migrations}.

\begin{listing}
  \input{listing/activerecord_migrations}
  \caption{Generator modelu oraz automatycznie utworzony plik migracji}
  \label{listing:activerecord_migrations}
\end{listing}


Ostatecznie zmiany wprowadzamy poprzez polecenie \texttt{rake db:migrate}\footnote{Rake --
Ruby Make -- odpowiednik unixowego Make, pozwalający na użycie języka Ruby. Twórcą
jest Jim Weirich}. Domyślnie \texttt{railsy} dodają dwie tzw. magiczne kolumny
\texttt{created\_at} oraz \texttt{updated\_at}, które są aktualizowane automatycznie, jak
nie trudno się domyślić, przy utworzeniu obiektu oraz jego aktualizacji.


\emph{ActiveResource} jest biblioteką umożliwiającą komunikację z innymi
aplikacjami railsowymi niemal przy tej samej składni jaka jest dostępna w \emph
{ActiveRecord}. Wystarczy że określimy \emph{host} zdalnego serwera i już
możemy korzystać z jego \emph{API},\footnote{API -- Application Programming
Interface (ang.) -- tutaj interfejs do komunikacji ze zdalną aplikacją} o ile
jest zgodne z konwencją REST.\footnote{więcej na stronie~\pageref{sec:rest}}
Moduł jest oparty o reprezentację zasobów w postaci \emph{XML} lub \emph{JSON
}.\footnote{JSON -- JavaScript Object Notation -- tekstowy format wymiany
danych, będący podzbiorem języka JavaScript}


\emph{ActiveResource} przynosi między innymi rozszerzenia biblioteki
standardowej o nowe metody, ułatwiające konwersję lub kalkulację na podstawowych
typach, takich jak \texttt{String}, \texttt{Date} czy \texttt{Numeric}. Przykłady
wykorzystania przedstawione na listingu nr~\ref{listing:activesupport}.

\begin{listing}
  \input{listing/activesupport}
  \caption{Pzykład dostępnych metod w ActiveSupport}
  \label{listing:activesupport}
\end{listing}


W ostatnim przykładzie widzimy metodę z pytajnikiem. Warto wspomnieć w tym
momencie o konwencji jaka przyjęła się w środowisku języka \emph{Ruby}, gdzie
właśnie metody zakończone pytajnikiem zwracają zawsze \texttt{true} lub \texttt
{false}, natomiast kończące się wykrzyknikiem są ,,groźniejszą'' wersją metody
bez wykrzyknika, co na przykład może oznaczać trwałą modyfikację argumentu.

\subsubsection{Internacjonalizacja}
Poczynając od wersji 2.2, \emph{Ruby on Rails} ma wbudowany mechanizm internacjonalizacji.
Tłumaczenie słów w widokach odbywa się poprzez wywołanie metody \texttt{translate
} aliasowanej do \texttt{t()} na kluczu, który następnie możemy zdefiniować w plikach z
naszym tłumaczeniem. Dodatkowo możemy tłumaczyć nazwy modeli, atrybutów, czy błędy
walidacji. Pliki z tłumaczeniem mogą być z rozszerzeniem \texttt{.rb}, wtedy zapisujemy je
w postaci tablic asocjacyjnych języka \emph{Ruby} lub rozszerzeniem \texttt{.yml}. \emph{
YAML}\footnote{YAML -- YAML Ain't Markup Language (ang.)} jest językiem formalnym
przeznaczonym do reprezentowania zbioru danych. Jego główną zaletą jest czytelność,
przeciwnie jak to jest w przypadku \emph{XMLa}. Nie ma tu otwieranych i zamykanych
znaczników, gdyż struktura bazuje na wcięciach, określając tym samym poziom zagnieżdżenia.


\subsubsection{Bezpieczeństwo aplikacji}
\emph{Ruby on Rails} ma wbudowane mechanizmy oraz metody pomagające nam zabezpieczyć się
przed najbardziej znanymi próbami ataku na naszą aplikację. Jednym z nich jest \emph{CSRF
}\footnote{CSRF -- Cross-site request forgery (ang.)}, który polega na podszyciu się
napastnika pod sesję użytkownika. Jeśli osoba taka jest zalogowana, wystarczy że uruchomi
odnośnik modyfikujący dane niedostępne bez aktywnej sesji. Innymi słowy zmusza się
użytkownika do wysłania żądania \emph{HTTP} do serwera z jego przeglądarki, wykorzystując
jego autentykację.\\
Sposobem na przeciwdziałanie jest dołączanie do parametrów przesyłanych do serwera,
unikalnego tokena, który jednoznacznie identyfikuje użytkownika. Token ten jest umieszczany
automatycznie w formularzach, gdzie wysyłamy żądania metodą \emph{POST}. Następnie po
stronie serwera jest porównywany z aktualnym kluczem sesji użytkownika. Dzięki temu
eliminujemy spreparowane formularze, które próbują modyfikować poufne dane.\\
Domyślnie mechanizm ten jest włączony dla każdej nowo tworzonej aplikacji railsowej i
sprowadza się do umieszczenia w kontrolerze głównym linijki: \texttt{protect\_from\_forgery}.


Kolejnym sposobem ataku może być tzw. \emph{XSS}\footnote{XSS -- Cross-site scripting
(ang.)} polegający na osadzeniu, w treści kodu strony, skryptu (najczęściej
javascriptowego), który może wyciągnąć z bazy danych poufne informacje. Przykładem niech
będzie serwis, na którym każdy użytkownik może pozostawić komentarz. Jeśli nie jest on
zabezpieczony, możemy wkleić kod, który przy kolejnym wyświetleniu strony, będzie potraktowany
przez naszą aplikację jako regularny kawałek kodu aplikacji, a więc zostanie wykonany.\\
Z pomocą przychodzi metoda \texttt{html\_escape} aliasowana jako po prostu \texttt{h()},
która zawsze traktuje przekazane słowa jako czysty tekst, lub metoda \texttt{sanitize},
dopuszczająca pewne zdefiniowane tagi \emph{HTMLowe}, które są uznawane za ,,bezpieczne''.


\subsubsection{Wdrażanie aplikacji}
Wdrażanie wersji produkcyjnej dotyczy serwera \emph{HTTP} oraz bazy danych, gdzie musimy
wziąć pod uwagę wydajność i szybkość obsłużenia zapytania. W wersji rozwojowej
wystarczające są domyślnie używane narzędzia, czyli napisany w \emph{Rubim} \emph{Webrick},
który służy nam jako lokalny serwer \emph{HTTP} oraz \emph{SQLite} jako system
zarządzania bazą danych.


\emph{SQLite} świetnie sprawdza się przy rozwoju aplikacji, gdyż baza danych jest trzymana
w jednym pliku umieszczonym w dogodnym dla nas miejscu. Nie musimy się przejmować
rozporzązaniem prawami dostępu czy zarządzaniem użytkownikami, a jeśli potrzebujemy nagle
wyrzucić istniejącą bazę, sprowadza się to po prostu do usunięcia danego pliku.
Co ciekawe \emph{SQLite} wydajnościowo wypada bardzo dobrze w przypadku jednego
użytkownika, dlatego jest używany w systemach wbudowanych\footnote{Embedded system (ang.) --
system komputerowy specjalnego przeznaczenia, który staje się integralną częścią
obsługiwanego przez niego sprzętu.\cite{embedded-system}} takich jak telefony komórkowe
czy urządzenia \emph{AGD}. Jednak przy obsłudze strony internetowej, gdzie jednoczesnych zapytań
skierowanych do bazy danych może być dużo, jest potrzebny osobny, odrębny serwer. Jednym
z najczęściej spotykanych wyborów jest \emph{PostgreSQL} lub \emph{MySQL}. Konfiguracja
po stronie railsów wymaga jedynie określenia nazwy użytkownika i ewentualnego hasła, które
zapisujemy w pliku \texttt{config/database.yml}.


Początkowo produkcyjnymi serwerami \emph{HTTP} były \emph{Mongrel} i \emph{Thin}, które
częściowo były pisane w języku \emph{C}, jednak od czasu wydania \emph{Phusion Passengera},
znanego również jako \texttt{mod\_rails} lub \texttt{mod\_rack}, rekomendowanym i
jednocześnie najczęściej używanym jest serwer \emph{Apache}.


\emph{Phsuion Passenger} jest modułem, dostępnym jako \texttt{gem}, który umożliwia
uruchomienie aplikacji pisanych w języku \emph{Ruby} opartych o bibliotekę \emph{Rack} na
serwerze \emph{HTTP} \emph{Apache}. \emph{Rack} z kolei, również w postaci \texttt{gema},
dostarcza uniwersalny interfejs do naszego kodu, dzięki któremu wszelkie serwery
wspierające \emph{Rubiego} mogą go hostować.


\subsubsection{Merb + Ruby on Rails}
\emph{Merb} początkowo był małym frameworkiem napisanym w języku \emph{Ruby}, by w
przeciągu kilku lat rozwinąć się i konkurować ze swoim starszym bratem \emph{Ruby on
Rails}. Twórcą jest Ezra Zygmuntowicz, który skupił się na szybkości działania aplikacji
oraz uniezależnieniu frameworka od konkretnej biblioteki \emph{ORM} oraz \emph{JavaScript
}. \emph{Merb} nastawiony był również na większą modularność, sam w sobie nie dawał tak
dużej funkcjonalności jak \emph{RoR}, ale rozszerzenie o nowe możliwości miało być
prostsze i wspierane przez zespół pracowników czuwających nad głównym kodem.\\
W dniu 23 grudnia 2008 roku została ogłszona wiadomość\cite{rails-merb} o połączeniu obu zespołów,
które razem skupią się na przeniesieniu najlepszych rzeczy z obu frameworków do jednego,
wypuszczonego pod nazwą \emph{Ruby~on~Rails~3.0}. Pierwszej wersji możemy się spodziewać
pod koniec 2009 roku. Informacja ta wzbudziła wiele emocji w środowisku deweloperskim, co
oczywiście też przeniosło się na promocję samych railsów. Obecnie, framework ten jest
jednym z najpopularniejszych i większość startujących, głównie opensourcowych,
projektów wybiera właśnie \emph{Ruby on Rails}.\\
Zmiany jakich spodziewamy się wraz z wydaniem wersji 3.0 to przede wszystkim większa
wydajność oraz niezależność. Będzie możliwy swobodny wybór bibliotek odpowiedzialnych za
\emph{JavaScript}, \emph{ORM}, silnik szablonów oraz moduł testujący. Twórcy zapewniają
również, że migracja aplikacji pisanych we wcześniejszych wersjach oraz \emph{Merbie} do nowej
wersji, nie będzie stwarzać problemu.


\subsection{REST}\label{sec:rest}
\emph{REST}\footnote{REST -- Representational State Transfer (ang.)} jest wzorcem
architektury oprogramowania, który próbuje przedstawić reprezentację zasobów oraz
zarządzanie nimi poprzez odpowiednie metody protokołu \emph{HTTP}. Możemy zobrazować to w
następujący sposób: adres \emph{URI} jest identyfikatorem określającym konkretny zasób
(obiekt), możemy myśleć o nim jako o rzeczowniku. Dopełnieniem sentencji jest czasownik,
który jest przedstawiony jako jedna z metod protokołu \emph{HTTP}: \emph{POST}, \emph{GET},
\emph{PUT} lub \emph{DELETE}. Budujemy gramatycznie poprawne ,,zdanie'' poprzez
połączenie rzeczownika z czasownikiem, otrzymując formę wywołania przesyłaną na serwer dla
konkretnego zasobu. Odpowiednio, chcąc pobrać dane, bez modyfikacji, powinniśmy użyć
metody \emph{GET}. \emph{POST} służy do tworzenia nowych obiektów, \emph{PUT} do ich
modyfikacji, natomiast \emph{DELETE} do usuwania.\\
Łączy się to wszystko świetnie z wykorzystaniem \emph{CRUD}\footnote{CRUD -- create, read,
update and delete (ang.)}, który sprowadza się do podstawowych akcji wykonywanych na
obiektach połączonych z bazą danych. Zestawienie oraz koneksję przestawia tabela nr
\ref{table:rest}.

\begin{table}[htcb]
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      \textbf{metoda HTTP} & \textbf{CRUD} & \textbf{SQL} & \textbf{akcja RoR}\\
      \hline
      \texttt{POST} & \texttt{Create} & \texttt{Insert} & \texttt{create}\\
      \texttt{GET} & \texttt{Read} & \texttt{Select} & \texttt{show}\\
      \texttt{PUT} & \texttt{Update} & \texttt{Update} & \texttt{update}\\
      \texttt{DELETE} & \texttt{Delete} & \texttt{Delete} & \texttt{destroy}\\
      \hline
    \end{tabular}
  \end{center}
  \caption{Powiązanie REST, CRUD, zapytań SQL oraz akcji RoR}
  \label{table:rest}
\end{table}

Jeśli trzymamy się przyjętych konwencji, to pzykładowy ciąg zdarzeń dla usunięcia danego
obiektu np. użytkownika, wyglądałby następująco: na serwer jest przesyłane żądanie pod
adresem \texttt{users/1}, gdzie \texttt{1} jest identyfikatorem osobnika, którego chemy
usunąć z bazy danych. Żądanie jest przesyłane metodą \emph{DELETE}, następnie po stronie
naszej aplikacji, mapowane na akcję \texttt{destroy} w kontrolerze \emph{UsersController},
aż w końcu przy użyciu \emph{ActiveRecord} jest generowane zapytanie \emph{SQL}, które
ostatecznie usuwa obiekt z bazy.\\
Warto wspomnieć w tym momencie, że przeglądarki obecnie nie wspierają wysyłania żądań
\emph{PUT} oraz \emph{DELETE}, co jednak railsy załatwiają sobie poprzez dodanie do
formularza ukrytego pola z nazwą docelowej metody, używając żądania \emph{POST}.\\
Domyślnym sposobem budowania aplikacji w \emph{Ruby on Rails} poczynając od wersji 2.0
jest właśnie \emph{REST}, który ma też duże znaczenie w przypadku wykorzystania \emph
{ActiveResource}, czyli budowania \emph{API} w celu udostępnienia zasobów dla innych
serwisów. Sprowadza się to praktycznie tylko do przedstawienia konkretnego obiektu lub
kolekcji poprzez format \emph{XML} lub \emph{JSON}.


\subsection{Shoulda i Cucumber}
\emph{Shoulda} jest biblioteką służącą do przeprowadzania testów jednostkowych w oparciu o
\emph{BDD}\footnote{BDD -- Behavior Driven Development (ang.)}. Ideą takiego podejścia
jest pisanie testów jeszcze przed stworzeniem kodu aplikacji, który opisuje funkcjonalność
jakiej mamy się spodziewać. Następnie piszemy kod właściwy, w taki sposób aby test
zakończył się powodzeniem. Później możemy zająć się refaktoryzacją, zabezpieczając się
cały czas istniejącymi testami, przed ewentualnym naruszeniem integralności kodu całej
aplikacji. Testy jednostkowe powinny zapewnić poprawne działanie tworzonych metod w
obrębie tylko jednej klasy. Jeśli jednak istnieją powiązania z innymi modelami, powinniśmy
się zastanowić nad użyciem jendej z bibliotek \emph{mockowania}\footnote{mock -- symulacja
zachowania prawdziwych obiektów w celach testowych}.\\
\emph{Shoulda} jest rozszerzeniem standardowej biblioteki testującej języka \emph{Ruby}
\emph{Test::Unit}, która przynosi wygodniejszą składnie oraz nowe typy asercji.


\emph{Cucumber}\footnote{Stworzony w języku Ruby przez Aslaka Hellesøya, więcej na stronie
internetowej \cite{cucumber}} zalicza się do tzw. \emph{Scenario Driven Development} i
służy do testowania funkcjonalności ostatecznej -- tej widocznej dla użytkownika. Polega
na napisaniu scenariusza, który zawiera poszczególne akcje użytkownika wykonywane z
poziomu przeglądarki. Składnia ogranicza się do kilku słów kluczowych, które poprzedzają
dowolny tekst opisujący zdarzenia. Następnie przy pomocy wyrażeń regularnych tekst jest
mapowany na definicję metod, pisanych już w języku \emph {Ruby}. Przykład można zobaczyć
na listingu nr~\ref{listing:cucumber}

\begin{listing}
  \input{listing/cucumber}
  \caption{Przykład testu integracyjnego z wykorzystaniem Cucumber}
  \label{listing:cucumber}
\end{listing}

\subsection{Haml i Sass}
\emph{Haml}\footnote{Haml -- HTML Abstraction Markup Language (ang.)} jest językiem
znaczników, który opisuje \emph{HTML} i \emph{XHTML}. Składnia wykorzystuje wcięcia, tak więc podobnie
jak w języku \emph{Python} nie musimy domykać raz otwartych tagów. Dzięki temu struktura
szablonu jest bardziej przejrzysta i trudniej nam się pomylić, gdyż przy błędnej składni
zostanie zwrócony wyjątek. Jak wiemy, w przypadku \emph{HTML}, nawet jeśli zapomnimy
domnknąć tag, to dokument i tak będzie wyświetlony w przeglądarce, błędy nie zwracają
wyjątku.\\
\emph{Haml} nie jest ściśle związany z żadnym językiem programowania i może być używany
również we frameworkach opartych o \emph{Python}, \emph{PHP} czy \emph{.NET}, co czyni
z niego narzędzie warte uwagi dla każdego dewelopera.


\emph{Sass}\footnote{Sass -- Syntactically Awesome Stylesheets (ang.)} jest dostępny razem
z biblioteką \emph{Haml} i służy do generowania kaskadowych arkuszy stylów \emph{CSS
}\footnote{CSS -- Cascading Style Sheets (ang.)}. Również bazuje na wcięciach, więc
wszelkie tagi są domykane automatycznie. Dodatkową zaletą poza przejrzystością i
zwięzłością języka, jest dostępność zmiennych, na których możemy wykonywać operacje
matematyczne. Przykładowo, jeśli mamy zdefiniowany jeden kolor i chcemy uzyskać np.
jaśniejszy, wystarczy że odejmiemy odpowiednią wartość od głównego. Kolejną cechą jest
obecność tzw. \texttt{mixinów}, dzięki którym możemy używać jednego fragmentu kodu w wielu
miejscach, bez powtarzania. Przykład na listingu nr~\ref{listing:sass}

\begin{listing}
  \input{listing/sass}
  \caption{Szablon w języku Sass generujący CSS}
  \label{listing:sass}
\end{listing}


\subsection{Blueprint i Compass}
\emph{Blueprint} jest frameworkiem \emph{CSS}, który posiada wiele gotowych arkuszy stylów
dotyczących poszczególnych sekcji strony internetowej, takich jak formularze, typografię,
listy, tabele, etc. Używamy go popzez dołączenie odpowiednich klas lub identyfikatorów do
znaczników \emph{HTMLa}. Zyskujemy automatyczne stylowanie, które oparte jest na
najlepszych doświadczeniach deweloperskich.\\
\emph{Blueprint} stara się ustandaryzować podział strony na najczęściej spotykane sekcje,
takie jak nagłówek, nawigacja, treść, stopka, a które mają mieć swoje odpowiednie
znaczniki w przygotowywanej 5 wersji języka \emph{HTML}. Ciekawym pomysłem jest
stylowanie względem siatki, która rodziela stronę na kilkanaście pasów. Wszelkie marginesy
oraz przesunięte elementy są właśnie dostosowywane do rozmiarów tychże części, dzięki czemu
estetyka strony jest zachowana.


\emph{Compass}\footnote{Twórcą jest Chris Eppstein, więcej na stronie internetowej
\cite{compass}} jest narzędziem napisanym w języku \emph{Ruby}, wykorzystującym język
\emph{Sass} oraz łączącym kilka najpopularniejszych frameworków \emph{CSS}, w tym
\emph{Blueprinta}. Jego główną cechą jest to, że nie musimy dodawać określonych klas i
identyfikatorów do znaczników \emph{HTMLa}, aby korzystać z dobrodziejstw gotowych stylów.
To my podporządkowujemy zebrane arkusze pod naszą strukturę strony. Głównie za sprawą
dostępnych w \emph{Sassie} \texttt{mixinów}, jesteśmy w stanie dodawać pojedyncze,
interesujące nas fragmenty gotowych rozwiązań.\\
Automatycznie dostajemy również wersję arkuszy stylów do druku strony i pod \emph{Internet
Explorera}, który niestety nie trzyma się przyjętych przez \emph{W3C}\footnote{W3C -- The
World Wide Web Consortium (ang.) -- organizacja zajmująca się ustanawianiem standardów pisania i
przesyłu stron WWW} standardów i często trzeba korygować jej niedoskonałości. Dotyczy to
zwłaszcza starszych wersji przeglądarek \emph{IE}, które na szczęście wychodzą powoli z
użytku.


\subsection{jQuery}
\emph{jQuery} jest biblioteką napisaną w \emph{JavaScripcie}, która dostarcza szereg
gotowych rozwiązań, najczęściej spotykanych na stronach internetowych. Duży wpływ na
rozwój kodu, oprócz twórcy Johna Resiga, ma Yehuda Katz, zajmujący się również rozwojem
\emph{Merba} oraz \emph{Ruby on Rails} (od czasu połączenia obu frameworków).
Jedną z głównych zalet jest niezależność od przeglądarki. Dostępne \emph{API} jest
uniwersalne, a więc biblioteka sama dba o wyrównanie nieścisłości wynikających właśnie ze
środowiska działania.\\
Dzięki \emph{jQuery} w prosty sposób możemy manipulować modelem \emph{DOM}\footnote{DOM --
Document Object Model (ang.)}, wykorzystując wygodne w użyciu selektory. Kolejną dostępną
funkcjonalnością jest komunikacja z serwerem za pomocą technologii
\emph{AJAX}\footnote{AJAX -- Asynchronous JavaScript and XML (ang.)}, która sprowadza się
jedynie do wywołania odpowiedniej funkcji. Tworzenie własnych rozszerzeń nie sprawia
problemu, dzięki czemu ilość dostępnych dodaktów jest ogromna.

\subsection{Git}
\emph{Git} jest rozproszonym systemem kontroli wersji stworzonym przez Linus Torvaldsa w 2005 roku.
Został on napisany na potrzeby rozwoju jądra \emph{Linux}, jednak obecnie jest używany
przez wiele znanych projektów, choćby takich jak: \emph{Android}, \emph{Amarok}, \emph{Perl},
czy \emph{Ruby on Rails}. Głównym celem była szybkość działania oraz nie powtarzanie błędów
zaistniałych w \emph{CVS}\footnote{CVS -- Concurrent Versions System (ang.)}.
Każdy katalog roboczy jest kompletnym repozytorium, który nie jest uzależniony od dostępu
do sieci czy centralnego serwera, co sprawia że świetnie sprawdza się również przy projekcie
prowadzonym tylko przez jedną osobę.\\
Jedną z możliwości hostowania repozytoriów oferuje \emph{GitHub}\cite{github}, który jest
skupiskiem wielu opensourcowych projektów. Statystyki na dzień 27.07.2009 mówią o 90.000
unikalnych publicznych repozytoriach znajdujących się na serwerach firmy\cite{github-statistics}.


\clearpage
\section{Opis środowiska uruchomienia}
\subsection{Ubuntu}
Aby uruchomić aplikację na systemie \emph{Ubuntu} wymagane są:
\begin{itemize}
  \item{Ruby wraz z interpreterem}
  \item{System paczek RubyGems}
  \item{Odpowiednie gemy (m.in. rails)}
  \item{Biblioteka imagemagick do obróbki ilustracji}
  \item{Biblioteka obsługująca bazę danych formatu SQLite3}
\end{itemize}


Opisany poniżej sposób instalacji i konfiguracji dotyczy wersji rozwojowej i testowej.
Chcąc uruchomić aplikację w środowisku produkcyjnym, zalecane jest skorzystanie z bazy
danych \emph{PostgreSQL} lub \emph{MySQL} oraz jednego z serwerów \emph{HTTP}:
\emph{Apache}, \emph{Mongrel} lub \emph{Thin}.


Sam system \emph{Ubuntu} możemy pobrać ze strony internetowej \cite{ubuntu}.
Następnie instalujemy \emph{Rubiego} w wersji 1.8. Najmniej kłopotów przysparza kompilacja ze
źródeł. Wystarczy, że pobierzemy stabilną wersję 1.8.7 ze strony \cite{ruby-package} i po
rozpakowaniu wydamy polecenia jak na listingu nr~\ref{listing:ubuntu_ruby} (przykład dla
wersji 1.8.7-p174)\footnote{Całość skryptu znajduje się w katalogu aplikacji, w pliku
extras/environment\_setup.sh}.

\begin{listing}
  \input{listing/1_sh_ruby}
  \caption{Instalacja Rubiego}
  \label{listing:ubuntu_ruby}
\end{listing}

Nastepnie ściągamy pakiet \emph{RubyGems} ze strony \cite{rubygems} i również kompilujemy,
jak na listingu nr~\ref{listing:ubuntu_rubygems}

\begin{listing}
  \input{listing/2_sh_rubygems}
  \caption{Instalacja RubyGems}
  \label{listing:ubuntu_rubygems}
\end{listing}

%Następnie możemy zainstalować gema \emph{RVM}\footnote{RVM -- Ruby Version Manager (ang.)
%}, aby mieć kilka wersji \emph{Rubiego}, np. 1.8 oraz 1.9 (różnice pomiędzy wydaniami
%zostały omówione na stronie ...).\\
%Pomoc możemy znaleźć na stronie internetowej \cite{rvm}. Sposób instalacji i konfiguracji
%na listingu nr~\ref{listing:ubuntu_rvm}
%
%\begin{listing}
%  %\input{listing/ubuntu_rvm}
%  \caption{Instalacja kilku wersji Rubiego}
%  \label{listing:ubuntu_rvm}
%\end{listing}

Aby ściągnąć aktualną wersję aplikacji, możemy posłużyć się \emph{Gitem}.
Najpierw instalujemy sam program, a następnie klonujemy kod do wybranego katalogu,
tak jak na listingu nr~\ref{listing:ubuntu_git}.

\begin{listing}
  \input{listing/3_sh_git}
  \caption{Instalacja systemu kontroli wersji Git}
  \label{listing:ubuntu_git}
\end{listing}

Teraz możemy przejść do folderu aplikacji, ściągnąć wymagane gemy i zmigrować bazę danych.
Aby przekonać się czy nasze środowisko jest w pełni gotowe do pracy, uruchamiamy testy
jednostkowe oraz integracyjne poprzez polecenia jak na listingu nr~\ref
{listing:ubuntu_application}.

\begin{listing}
  \input{listing/4_sh_application}
  \caption{Instalacja gemów, migracja bazy, uruchomienie testów}
  \label{listing:ubuntu_application}
\end{listing}

Jeśli wszystko się powiodło możemy uruchomić serwer poleceniem z listingu nr~\ref
{listing:ubuntu_start_server}. Nasza aplikacja jest dostępna pod adresem
\url{http://localhost:3000}.

\begin{listing}
  \input{listing/5_sh_start_server}
  \caption{Uruchomienie lokalnego serwera aplikacji}
  \label{listing:ubuntu_start_server}
\end{listing}

\clearpage
\section{Implementacja}

\subsection{Wykorzystane gemy}
\subsubsection{authlogic}
Autorem gema \emph{Authlogic} jest Ben Johnson. Służy on do systemu autentykacji,
począwszy od mechanizmu rejestracji, poprzez zarządzanie sesją użytkownika, aż do
zabezpieczeń przed próbami włamania na konto za pomocą tzw. \emph{Brute
Force}\footnote{Brute Force (ang.) -- próba złamania hasła poprzez sukcesywne sprawdzanie
wszystkich dostępnych możliwości}.


Przy tworzeniu tabeli użytkowników jest zalecane umieszczenie kilku dodaktowych kolumn,
które automatycznie się aktualizują i będą przechowywać takie informacje jak: ilość
logowań, ostatni czas aktywności, ostatni adres \emph{IP} komputera z którego nastąpiło
logowanie, etc.\\
Hasło użytkownika przed zapisaniem do bazy danych jest łączone z tzw. ,,solą'', czyli
dodatkowym ciągiem znaków, zapisywanych również w bazie danych, a następnie przeliczane
funkcją skrótu \emph{SHA1}\footnote{SHA -- Secure Hash Algorithm (ang.)}
dziesięciokrotnie, co ma utrudnić odszyfrowanie hasła z postaci samego skrótu.\\
Gem ten również zapewnia nam wszystkie niezbędnę walidacje, takie jak poprawność składni
wprowadzanego adresu e-mailowego oraz loginu, zgodność hasła z potwierdzeniem, czy
unikalność istotnych atrybutów. Przykład użycia na listingu nr~\ref{listing:authlogic}

\begin{listing}
  \input{listing/authlogic}
  \caption{Sposób użycia systemu autentykacji}
  \label{listing:authlogic}
\end{listing}


W aplikacji sesja nauczyciela i studenta jest zrealizowana za pomocą jednego modelu, co
oznacza, że nie ma rozróżnienia pomiędzy sposobem logowania do serwisu. Po zalogowaniu
jednak, jest rozpoznawany typ użytkownika i na tej podstawie jest wyświetlany panel z menu
dla odpowiedniej osoby oraz sprawdzane są prawa dostępu do poszczególnych podstron.

\subsubsection{acts-as-list}
\emph{Acts as list} umożliwia nam dołączęnie do modelu funkcjonalność listy, czyli
usystematyzowanie kolejności występowania poszczególnych rekordów. Idea ta została
wykorzystana w aplikacji przy tworzeniu pytań i dostępnych odpowiedzi w danym teście.
Dla każdego studenta, z puli dostępnych pytań, jest losowana kolejność pojawienia się ich w
teście, która jest zapisywana w bazie danych. Dzięki temu dla każdej nowej próby podejścia
do testu, czyli również dla poszczególnych studentów, kolejność ta jest różna.
Analogicznie, przy pytaniach wielokrotnego lub jednokrotnego wyboru, jest losowana
kolejność wystąpienia odpowiedzi.

\subsubsection{acts-as-taggable-on}
\emph{Acts as taggable on} jest gemem, który łączy w sobie kilka poprzednio utworzonych
bibliotek o podobnej funkcjonalności. Dostarcza mechanizm tagowania wybranych przez
nas rekordów. Tagi mogą być tworzone w różnym kontekście, co oznacza możliwość grupowania
ich nie tylko po tworzonych, konkretnych nazwach, ale też w ujęciu poszczególnych
atrybutów. Możliwe jest również określenie właściciela poszczególnych tagów, dzięki czemu
tworzone rekordy nie muszą być globalne, a widoczne tylko dla autora.\\
Przykład wykorzystania mechanizmu tagowania na listingu nr~\ref{listing:tagging_questions}

\begin{listing}
  \input{listing/tagging_questions}
  \caption{Sposób użycia mechanizmu tagowania}
  \label{listing:tagging_questions}
\end{listing}


W aplikacji tagowanie zostało wykorzystane w klasie \texttt{TeacherQuestion}, tak aby
każdy nauczyciel miał wygodny mechanizm określania dziedziny tworzonego przez siebie
pytania. W analgoiczny sposób tagi zostały dodane do modelu \texttt{Student}, aby móc
łatwo przydzielić ich do odpowiednich grup. Na listingu nr~\ref{listing:tagging_users}
kontekstem tagowania są grupy, a właścicielem nauczyciel.

\begin{listing}
  \input{listing/tagging_users}
  \caption{Mechanizm tagowania w kontekście grup}
  \label{listing:tagging_users}
\end{listing}


Jak widzimy, możemy zawęzić wyszukiwanie odpowiednich rekordów do autora tagów.\\
Gem udostępnia też metody pomocnicze przy wyświetlaniu tzw. ,,chmury tagów'' w
renderowanych widokach, które możemy stylować za pomocą klas \emph{CSS}.

\subsubsection{prawn}
\emph{Prawn} jest odpowiedzialny za generowanie dokumentów w formacie
\emph{PDF}\footnote{PDF -- Portable Document Format (ang.)}. Dostarcza on prosty format
szablonu, w którym mozemy zagnieżdżać kod \emph{Rubiego} jednocześnie stylując
w podstawowy sposób wygląd dokumentu. Integracja z aplikacją railsową jest zapewniona
poprzez plugin \texttt{prawnto}. Pliki zapisywane są z rozszerzeniem \texttt{.pdf.prawn},
czyli zgodnie z konwencją, pierwszy element jest żądanym formatem odpowiedzi serwera,
a drugi jest nazwą silnika generującego ostateczną postać dokumentu przesłanego do klienta.\\
Przykład szablonu znajduje się na listingu nr~\ref{listing:prawn}

\begin{listing}
  \input{listing/prawn}
  \caption{Szablon wykorzystywany przy generowaniu dokumentu PDF}
  \label{listing:prawn}
\end{listing}

\subsubsection{paperclip}
\emph{Paperclip} jest gemem, który obsługuję ładowanie oraz obróbkę plików wysyłanych na
serwer z poziomu użytkownika. Jest zintegrowany z biblioteką \emph{ActiveRecord}, dzięki
czemu użycie nie różni się zbytnio od dobrze znanych nam konwencji. Do działania wymaga
jedynie zainstalowanej w systemie biblioteki \emph{ImageMagick}, poprzez którą są tworzone
miniaturki czy innego rodzaju konwersje na plikach graficznych. Dostajemy również zestaw
walidatorów, które mogą określać typ przesyłanego pliku oraz jego wielkość.\\
W aplikacji gem ten został wykorzystany przy załączaniu ilustracji do pytań oraz odpowiedzi.
Sposób użycia na listingu nr~\ref{listing:paperclip}

\begin{listing}
  \input{listing/paperclip}
  \caption{Sposób wykorzystania gema Paperclip}
  \label{listing:paperclip}
\end{listing}


W podanym przykładzie model \texttt{Picture} korzysta z metody \texttt{has\_attached\_file}
dostarczonej przez \emph{Paperclipa}. Przed zapisaniem, ilustracja będzie poddana obróbce
i zgodnie z kodem, wersja oryginalna zostanie przekształcona do wielkości 250 pikseli,
jesli nie jest mniejsza oraz zostanie utworzona miniaturka o proporcjonalnych
wielkościach, nie większych niż 50 piskeli. Możemy również zdefiniować ścieżkę, pod jaką
ilustarcja będzie widziana z poziomu przeglądarki oraz docelowy folder w naszej
składowania w naszej aplikacji. Walidacja zapewnia, że format przyjętego pliku będzie
ograniczony tylko do \emph{JPEG}\footnote{JPEG -- nazwa jest akronimem od nazwy komitetu,
który ustanowił ten standard -- Joint Photographic Experts Group (ang.)},
\emph{PNG}\footnote{PNG -- Portable Network Graphics (ang.)} lub \emph{GIF}\footnote{GIF --
Graphics Interchange Format (ang.)}, oraz rozmiar nie przekroczy 100 kilobajtów.

\subsubsection{routing-filter}
Przełączanie pomiędzy różnymi wersjami językowymi aplikacji zostało zrealizowane w taki
sposób, aby był dodawany przedrostek do adresu strony w postaci kodu używanego aktualnie
języka. Drugim sposobem implementacji mogłoby być przechowywanie informacji o języku w sesji
lub ciasteczku, przez co \emph{URL} zmieniałby się tylko w chwili przełączania, a pomiędzy
kolejnymi żądaniami zmienna ta byłaby odczytywana na podstawie przechowywanej danej.
Idąc jednak za radą oficjalnych przewodników \emph{Ruby on Rails}\cite{rails-guides},
pierwszy sposób nie burzy podstawowych założeń sieci, mianowicie chcąc przesłać odnośnik
do strony, powinien on przedstawiać dokładnie tą samą treść, dlatego informacja o języku
tłumaczenia w adresie \emph{URL} jest niezbędna.


Napotykamy jednak na problem przy definiowaniu ścieżek, które są mapowane na kontrolery i
odpowiednie akcje. Okazuje się bowiem, że musielibyśmy przy każdym wewnętrznym odsyłaczu,
mapować dodatkowo parametr odpowiedzialny za informację o języku. Z pomocą jednak
przychodzi gem \emph{Routing filter}, który pozwala na używanie powyżej opisanego
mechanizmu bez przejmowania się o konfigurację ścieżek. Działa na zasadzie przechwycenia
pełnego adresu \emph{URL} przed odwołaniem się do kontrolera, sparsowaniu go, aż w końcu
po wykonaniu logiki oraz przekierowaniu, ,,doklejeniu'' usuniętego wcześniej parametru.
Twórcą gema jest Sven Fuchs, który jest również głównym autorem modułu internacjonalizacji
w \emph{Ruby on Rails}.

\subsubsection{formtastic}
\emph{Formtastic} jest narzędziem, który rozbudowuje domyślny mechanizm konstruowania
formularzy w railsach, dostarczając prostszy interfejs na rzecz, zdefiniowanych przez
autora, struktury oraz klas \emph{CSS}. Biblioteka ta, na podstawie asocjacji deklarowanych
w klasach, potrafi odnaleźć odpowiednią kolekcję istniejących obiektów, przy polu wyboru
formularza. Etykiety opisujące wprowadzane dane korzystają z lokalizowanych nazw atrybutów
poszczególnych modeli. Typ wyświetlonego pola formularza jest ropoznawany na podstawie
odpowiadającej mu kolumnie w bazie danych. Wszystko to sprawia, że zbudowanie podstawowego
formularza sprowadza się do kilku linijek kodu. Przykład na listingu
nr~\ref{listing:formtastic}.

\begin{listing}
  \input{listing/formtastic}
  \caption{Wykorzystanie gema upraszczajacęgo konstruowanie formularzy}
  \label{listing:formtastic}
\end{listing}


Tworzymy nowy egzamin, pierwszym polem jest nazwa, którą wprowadzamy poprzez wpisanie
tekstu -- domyślny sposób dla kolumn typu \emph{String}. Następnie wpisujemy liczbę pytań,
która jednak nie jest pozycją wymaganą, przez co będzie otoczoną inną klasą \emph{CSS}.
Do daty rozpoczęcia, przekazujemy parametr, który ustala pierwszą z możliwych dat do
wyboru (w naszym przypadku jest to rok obecny). Do pola czasu trwania przekazujemy
wskazówkę, która wyświetli się pod wprowadzaną wartością, \emph{Formtastic} automatycznie
dodaje odpowiednie klasy, które możemy później wystylować w odpowiedni dla nas sposób. Na
samym końcu wybieramy pytania, które chcemy dołączyć, kolekcja jest tu przekazana
eksplicite, domyślnie byłyby wyświetlone wszystkie istniejące rekordy w bazie danych.

\subsection{Odległość Levenshteina}
Jednym z rodzajów tworzonego pytania jest pole tekstowe. Po wyborze tego właśnie typu, w
treści odpowiedzi wpisujemy wzorzec, który będzie porównany z odpowiedzią wpisaną przez
studenta.\\
Porównanie odbywa się na zasadzie przyrównywania kolejnych liter wzorca do otrzymanego
rozwiązania. Pojawia się jednak problem z tzw. ,,literówkami''. Co w przypadku gdy student
napisze dane słowo z dużej litery lub pomyli kolejność liter (często zdarzający się błąd)?
W celu rozwiązania powyższej przeszkody, przyjąłem dwa uproszczenia, mianowicie przy
porównaniu:
\begin{itemize}
  \item nie będzie brana pod uwagę wielkość liter
  \item na każde 6 liter wzorca jest możliwy jeden błąd
\end{itemize}
Do realizacji drugiego podpunktu została użyta odległość Levenshteina, która docelowo
oblicza wartość liczbową pomiędzy dwoma ciągami znaków, dzięki czemu jesteśmy w stanie
ocenić jak bardzo różnią się od siebie porównywane napisy.\\
Definicję można przedstawić w następujący sposób: \cite{levenshtein}\\
Odległością pomiędzy dwoma napisami jest najmniejsza liczba działań prostych,
przeprowadzających jeden napis w drugi, gdzie działaniem prostym nazwiemy:
\begin{itemize}
  \item wstawienie nowego znaku do napisu
  \item usunięcie znaku z napisu
  \item zamianę znaku w napisie na inny znak
\end{itemize}
Mając obliczoną odległość pomiędzy wzrocem a odpowiedzią, mierzymy długość wzorca i
dzielimy przez 6, jeśli wynik jest większy bądź równy od odległości, uznajemy odpowiedź
za poprawną. Liczba 6 została zaczerpnięta z polskiej wersji portalu NerdQuiz, gdzie
zastosowany jest podobny mechanizm oceny.

\clearpage
\tableofcontents
\clearpage
\bibliographystyle{plain}
\bibliography{bibliografia}
\end{document}
