\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{float}

\input{pygments}

\providecommand{\imref}[1]{Rys. \ref{#1}} % referencja do obrazka

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{leo}

\newfloat{listing}{thpb}{lol}
\floatname{listing}{Listing}

\begin{document}

\author{Wojciech Wnętrzak}
\title{Opracowanie elastycznego systemu organizacji testów internetowych do zdalnej
edukacji w oparciu o technologię Ruby on Rails}
\date{\today}

\begin{titlepage}
\maketitle
\end{titlepage}

\section{Technologie}
\subsection{Ruby}
\emph{Ruby} został stworzony w 1995 roku przez Yukihiro Matsumoto, znanego również
pod pseudonimem Matz. Łączy on w sobie cechy kilku języków, między innymi: \emph{Lispa},
\emph{Perla}, \emph{Pythona} czy \emph{Smalltalka}, z każdego wybierając to co najlepsze,
w efekcie dając elastyczne narzędzie, o wielkich możliwościach.\\
Jest to język skryptowy — aby spróbować jego możliwości wystarczy nam konsolowy
interpreter, z poziomu którego wydajemy polecenia, otrzymując od razu wynik działania.


\emph{Ruby} należy do grupy języków bardzo wysokiego poziomu programowania
(\emph{VHLL})\footnote{VHLL — Very High-Level Programming Language (ang.)}.
W bibliotece standardowej otrzymujemy szereg metod, dzięki którym bez zbytniego wysiłku,
czasem nawet w jednej linijce, możemy napisać skrypt wykonujący złożone działania.\\
Jedną z głównych cech tego języka, która rzuca się w oczy od razu, jest tzw.
,,samokomentujący się kod''. Składnia jest bardzo zbliżona do języka naturalnego
(angielskiego), dzięki czemu nawet osoba nie mająca nic wspólnego z programowaniem,
powinna przewidzieć co dany kawałek kodu wykonuje. Przykładem niech będzie:
\begin{listing}
  \input{listing/selfcommenting}
  \caption{Samokomentujący się kod}
  \label{listing:selfcommenting}
\end{listing}


Ciekawą własnością jest tzw. kacze typowanie\footnote{Duck typing (ang.)}, które polega na
rozpoznaniu typu poprzez zachowanie obiektu a nie jego deklaracji. Przykładowo: jeśli mamy
funkcję przyjmującą argument, to nie musimy określać jakiego on będzie typu, dzięki czemu
możemy wywołać na nim metodę (jeśli takową posiada), odpowiednią dla klasy obiektu. Nazwa
wzięła się z powiedzienia ,,Jeśli chodzi jak kaczka i kwacze jak kaczka, to musi być
kaczką''\footnote{''If it walks like a duck and quacks like a duck, I would call it a duck''
— James Whitcomb Riley (ang.)}


Kolejną cechą, która jest jedną z najsilniejszych, jest metaprogramowanie. Nie tyle sama
możliwość, co raczej przystępność i prostota jego użycia. Framework \emph{Ruby on Rails}
korzysta bardzo często z jego dobrodziejstw, dając nam tzw. ,,magię railsów'', czyli
między innymi dynamiczne findery, niemalże bezdeklaratywne asocjacje czy szereg innych
metod o których więcej w kolejnym podrozdziale.\\
Ogólnie rzecz biorąc język \emph{Ruby} wraz ze swoimi otwartymi klasami, stwarza
programiście przestrzeń, w której może się skupić wyłącznie na postawionym problemie, nie
martwiąc się o przeszkody techniczne, takie jak dostęp do modyfikacji metod z zewnętrznych
bibliotek czy rozszerzanie klas o nowe funkcjonalności. Sposób pisania jest intuicyjny,
działa tu zasada najmniejszego zaskoczenia. Często, powstające nowe biblioteki (gemy), trzymają
się kilku ustalonych konwencji, dzięki czemu zgłębiając nowe funkcjonalności, odnajdujemy
duże podobieństwa do już dobrze znanych nam metod, choćby z biblioteki standardowej.

\clearpage
\subsection{Ruby on Rails}
Twórcą frameworka \emph{Ruby on Rails} jest David Heinemeier Hansson. Powstał on w 2003
roku, obecnie rozwijany cały czas przez społeczność użytkowników i czuwającą nad
spójnością kodu tzw. \emph{Core Team}. Jest to produkt wolnego
oprogramowania\footnote{Open source (ang.)}, wypuszczony na licencji
\emph{MIT}.\footnote{Licencja powstała w Massachusetts Institute of Technology}.\\
Framework jest kompletnym narzędziem do tworzenia aplikacji internetowych z wykorzystaniem
bazy danych. Opiera się na wzorcu projektowym model-widok-kontroler\footnote{MVC — Model View
Controller (ang.)} i w całości jest napisany w języku \emph{Ruby}.\\
Główną zasadą jaką kierują się twórcy, to tzw. konwencja nad
konfiguracją\footnote{Convention over Configuration (ang.)}, dzięki której przy minimalnej
ilości kodu, dostajemy ogromną funkcjonalność, co znacznie przyspiesza tworzenie
aplikacji. Świetnym przykładem jest \emph{screencast}, na którym Ryan
Bates\footnote{Ryan Bates — jeden z aktywistów Ruby on Rails, znany głównie jako autor
darmowych, cotygodniowych screencastów \cite{ryan-bates}} tworzy w 15 minut szkielet
systemu blogowego, uwzględniając takie dodatki jak dostępność poprzez kanał
RSS\footnote{RSS — Really Simple Syndication (ang.)} czy reprezentacja zasobów w postaci
\emph{XML}.\cite{blog-in-15-min}\\
Kolejną zaletą takiego podejścia, jest przejrzystość kodu. Dopóki postępujemy zgodnie ze
wskazówkami, nasz kod nie powinien być trudny do zrozumienia przez innego programistę
również zajmującego się tą technologią.\\
Drugą ideą składającą się na całość tzw. \emph{Rails way} jest zapobieganie powtarzaniu
samego siebie\footnote{DRY — Don't Repeat Yourself (ang.)}. Jeśli w jakimś miejscu używamy
tego samego fragmentu kodu (czasem wręcz przeklejonego), to znaczy że możemy to zrobić
prościej. Pomoc przychodzi z samego języka \emph{Ruby}, w którym za pomocą mechanizmu
tzw. \emph{Mixinów}, możemy dodawać do interesujących nas klas czy modułów gotowe zestawy
metod, upraszczając w ten sposób strukturę kodu.

\clearpage
\section{Odległość Levenshteina}
Jednym z rodzajów tworzonego pytania jest pole tekstowe. Po wyborze tego właśnie typu, w
treści odpowiedzi wpisujemy wzorzec, który będzie porównany z odpowiedzią wpisaną przez
studenta.\\
Porównanie odbywa się na zasadzie przyrównywania kolejnych liter wzorca do otrzymanego
rozwiązania. Pojawia się jednak problem z tzw. ,,literówkami''. Co w przypadku gdy student
napisze dane słowo z dużej litery lub pomyli kolejność liter (często zdarzający się błąd)?
W celu rozwiązania powyższej przeszkody, przyjąłem dwa uproszczenia, mianowicie przy
porównaniu:
\begin{itemize}
  \item nie będzie brana pod uwagę wielkość liter
  \item na każde 6 liter wzorca jest możliwy jeden błąd
\end{itemize}
Do realizacji drugiego podpunktu została użyta odległość Levenshteina, która docelowo
oblicza wartość liczbową pomiędzy dwoma ciągami znaków, dzięki czemu jesteśmy w stanie
ocenić jak bardzo różnią się od siebie porównywane napisy.\\
Definicję można przedstawić w następujący sposób: \cite{levenshtein}\\
Odległością pomiędzy dwoma napisami jest najmniejsza liczba działań prostych,
przeprowadzających jeden napis w drugi, gdzie działaniem prostym nazwiemy:
\begin{itemize}
  \item wstawienie nowego znaku do napisu
  \item usunięcie znaku z napisu
  \item zamianę znaku w napisie na inny znak
\end{itemize}
Mając obliczoną odległość pomiędzy wzrocem a odpowiedzią, mierzymy długość wzorca i
dzielimy przez 6, jeśli wynik jest większy bądź równy od odległości, uznajemy odpowiedź
za poprawną. Liczba 6 została zaczerpnięta z polskiej wersji portalu NerdQuiz, gdzie
zastosowany jest podobny mechanizm oceny.

\clearpage
\bibliographystyle{plain}
\bibliography{bibliografia}
\end{document}
